* Writing Compatible Code

If you need to use Python 2 now and want to move more easily to Python
3 in the future when it becomes the standard version on your system,
use one of the bridge packages. A good strategy is to import the
standard __future__ module. This includes features to make Python 2
work like Python 3, and leave Python 3 code unharmed.

** print_function — parenthesized arguments, redirection, and output separators.
** unicode_literals — quoted strings are Unicode sequences, not bytes.
** division — dividing integers with / makes a float, with // makes an integer.
** absolute_import — ensure you’re importing what you expect when multiple modules have the same name.

* Hints and Tips

** The `in` operator

The `in` operator is a membership test. It can be used to see if one
thing is "in" another. One cool usecase is checking substrings. Here
is a way to see if one file is a subset of another:

https://unix.stackexchange.com/questions/114877/how-to-know-if-a-text-file-is-a-subset-of-another#114882

#+BEGIN_SRC
python -c 'x=open("file1").read();y=open("file2").read()";print(x in y)'
#+END_SRC

This reads each file into a variable as a string of bytes and then
looks for one string in the other file. This is much better than
line-by-line comparison.

** Snippets
*** Strings

Print string as hex:
#+BEGIN_SRC python
s = "Hello World !!"
":".join("{:02x}".format(ord(c)) for c in s)
#+END_SRC


** Virtual Environments

In Anaconda, you can use conda

#+BEGIN_SRC bash
conda create --name <envname>

conda create --name test python=3.6
conda env list
source activate <env>

#+END_SRC

In generic python you can do
#+BEGIN_SRC
mdd_toolkit) ➜  ~/scratch/project  $ pyvenv
WARNING: the pyenv script is deprecated in favour of `python3.6 -m venv`
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
            [--upgrade] [--without-pip] [--prompt PROMPT]
            ENV_DIR [ENV_DIR ...]
venv: error: the following arguments are required: ENV_DIR
#+END_SRC
** Packaging
python setup.py bdist_wheel ==> builds a wheel archive.

** OO
Derived classes don't call base class __init__ (or other) functions by default. Child overrides them, so you have to be explicit.

#+BEGIN_SRC python
>>> class Base:
...     def __init__(self):
...             print("Base::__init__")
...
>>> class Derrived(Base):
...     def __init__(self):
...             print("Derrived::__init__")
...
...
>>> obj = Derrived()
Derrived::__init__
#+END_SRC

To make this do what I expect:

#+BEGIN_SRC

>>> class Derrived(Base):
...     def __init__(self):
...             print("Calling Base.__init__")
...             Base.__init__(self)
...             print("Derived.__init__ end")
...
>>> obj = Derrived()
Calling Base.__init__
Base::__init__
Derived.__init__ end
#+END_SRC

And the attributes are not shared, so I can't do obj.val and see the Base "val".

* Pandas
** Examples
Create a dataframe using the constructor. Helps to see how the
different fields interact.
#+BEGIN_SRC
>>> df3 = pd.DataFrame([[0,100,50],[-1,12,6],[3,6,4.5]],['A312','A313','A315'],columns=['min','max','mean'])
>>> df3
      min  max  mean
A312    0  100  50.0
A313   -1   12   6.0
A315    3    6   4.5
#+END_SRC
